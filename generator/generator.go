package main

// For correct functionality, only run this file by using "go generate" in the main directory

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
)

var langauges_url = "https://raw.githubusercontent.com/boyter/scc/refs/heads/master/languages.json"

type writer struct {
	languages_info  map[string]map[string]any
	custom_mappings map[string]map[string]any
	file_lines      []string
	languages_used  map[string]struct{}
}

// Load languages.json from scc and custom_mappings.json from user
func (w *writer) load_files() {
	// load languages.json
	resp, err := http.Get(langauges_url)
	if err != nil {
		panic(fmt.Sprintln("Error accessing languages.json:", err))
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(fmt.Sprintln("Error reading languages.json:", err))
	}

	err = json.Unmarshal(body, &w.languages_info)
	if err != nil {
		panic(fmt.Sprintln("Error unmarshalling languages.json:", err))
	}

	// load custom_mappings.json
	file, err := os.Open("custom_mappings.json")
	if err != nil {
		if !os.IsNotExist(err) {
			fmt.Println("Error opening custom_mappings.json", err)
		}
		return
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	err = decoder.Decode(&w.custom_mappings)
	if err != nil {
		fmt.Println("Error reading custom_mappings.json", err)
		return
	}
}

// Generate file lines, write to languages.go
func (w *writer) write_file() {
	w.generate_text()

	file_text := strings.Join(w.file_lines, "")
	err := os.WriteFile("languages.go", []byte(file_text), 0666)
	if err != nil {
		panic(fmt.Sprintln("Error writing to languages.go:", err))
	}
}

// Turn languages_info and custom_mappings into the lines of languages.go
func (w *writer) generate_text() {
	var extra string
	if len(w.custom_mappings) > 0 {
		extra = " with custom mappings"
	}
	do_not_edit_text := fmt.Sprintf("\n// This file was generated by generator.go using \"go generate\"%s, DO NOT EDIT\n", extra)
	w.file_lines = append(w.file_lines, "package main\n", do_not_edit_text)

	extension_mappings, filename_mappings, single_char_mappings := w.gather_language_info()
	w.generate_extensions_map(extension_mappings)
	w.generate_filenames_map(filename_mappings)
	w.generate_single_chars_map(single_char_mappings)
}

// Load relevant information from languages.json into maps
func (w *writer) gather_language_info() (map[string]string, map[string]string, map[string][]any) {
	extension_mappings := make(map[string]string)
	filename_mappings := make(map[string]string)
	single_char_mappings := make(map[string][]any)

	for language, info := range w.languages_info {
		// process extensions, resolve conflicts
		extensions, ok := info["extensions"].([]any)
		if !ok {
			fmt.Println("Error getting extensions for", language)
		} else {
			for _, ext := range extensions {
				ext, ok := ext.(string)
				if !ok {
					fmt.Println("Error reading extensions for", language)
				} else {
					current_mapping, ok := extension_mappings[ext]
					if ok {
						// sort languages alphabetically for deterministic output
						langs := []string{current_mapping, language}
						sort.Strings(langs)
						extension_mappings[ext] = fmt.Sprintf("%s or %s", langs[0], langs[1])
					} else {
						extension_mappings[ext] = language
					}
				}
			}
		}

		// process filenames
		filenames, ok := info["filenames"].([]any)
		// no warning because filenames are optional in languages.json
		if ok {
			for _, file := range filenames {
				file, ok := file.(string)
				if !ok {
					fmt.Println("Error reading filenames for", language)
				} else {
					filename_mappings[file] = language
				}
			}
		}

		// process single line comment characters
		chars, ok := info["line_comment"].([]any)
		if !ok {
			fmt.Println("Error getting single comment chars for", language)
		} else {
			single_char_mappings[language] = chars
		}
	}

	return extension_mappings, filename_mappings, single_char_mappings
}

// Generate definition for extensions map
func (w *writer) generate_extensions_map(extension_mappings map[string]string) {
	// create union of extension_mappings and custom_mappings, record languages referenced
	custom_extensions, ok := w.custom_mappings["extensions"]
	if ok {
		for extension, language := range custom_extensions {
			language, ok := language.(string)
			if !ok {
				fmt.Println("Error reading custom extensions for", language)
			} else {
				extension_mappings[extension] = language
			}
		}
	}

	// record file lines
	w.file_lines = append(w.file_lines, "\n// Languages and extensions recognized as code")
	w.file_lines = append(w.file_lines, "\nvar extensions = map[string]string{")
	for _, extension := range sortKeys(extension_mappings) {
		language := extension_mappings[extension]
		new_line := fmt.Sprintf("\n\t\".%s\": \"%s\",", extension, language)
		w.file_lines = append(w.file_lines, new_line)
		w.languages_used[language] = struct{}{}
	}
	w.file_lines = append(w.file_lines, "\n}\n")
}

// Generate definition for filenames map
func (w *writer) generate_filenames_map(filename_mappings map[string]string) {
	// create union of filename_mappings and custom_mappings, record languages referenced
	custom_filenames, ok := w.custom_mappings["filenames"]
	if ok {
		for filename, language := range custom_filenames {
			language, ok := language.(string)
			if !ok {
				fmt.Println("Error reading custom filenames for", language)
			} else {
				filename_mappings[filename] = language
			}
		}
	}

	// record file lines
	w.file_lines = append(w.file_lines, "\n// Specific file names recognized as a particular language")
	w.file_lines = append(w.file_lines, "\nvar filenames = map[string]string{")
	for _, filename := range sortKeys(filename_mappings) {
		language := filename_mappings[filename]
		new_line := fmt.Sprintf("\n\t\"%s\": \"%s\",", filename, language)
		w.file_lines = append(w.file_lines, new_line)
		w.languages_used[language] = struct{}{}
	}
	w.file_lines = append(w.file_lines, "\n}\n")
}

// Generate definition for single_line_comment_chars map
func (w *writer) generate_single_chars_map(single_char_mappings map[string][]any) {
	// create union of single_char_mappings and custom_single_chars
	custom_single_chars, ok := w.custom_mappings["single_line_comment_chars"]
	if ok {
		for language, chars := range custom_single_chars {
			chars, ok := chars.([]any)
			if !ok {
				fmt.Println("Error getting custom single comment chars for", language)
			} else {
				single_char_mappings[language] = chars
			}
		}
	}

	// record file lines
	w.file_lines = append(w.file_lines, "\n// Single-line comment characters for all languages")
	w.file_lines = append(w.file_lines, "\nvar single_line_comment_chars = map[string][]string{")
	// add escape characters where necessary
	add_escape_chars := map[string]string{"\"": "\\\""}
	for _, language := range sortKeys(single_char_mappings) {
		// skip languages that don't appear in either of the other maps
		if _, ok := w.languages_used[language]; !ok {
			continue
		}

		char_set := single_char_mappings[language]
		if len(char_set) > 0 {
			var chars []string
			for _, char := range char_set {
				char, ok := char.(string)
				if !ok {
					fmt.Println("Error reading single comment chars for", language)
				}
				if escaped_char, ok := add_escape_chars[char]; ok {
					chars = append(chars, escaped_char)
				} else {
					chars = append(chars, char)
				}
			}
			new_line := fmt.Sprintf("\n\t\"%s\": {\"%s\"},", language, strings.Join(chars, "\", \""))
			w.file_lines = append(w.file_lines, new_line)
		} else {
			w.file_lines = append(w.file_lines, fmt.Sprintf("\n\t\"%s\": {},", language))
		}
	}
	w.file_lines = append(w.file_lines, "\n}\n")
}

// Generate languages.go from scc's languages.json and user's custom_mappings.json
func main() {
	writer := newWriter()
	writer.write_file()
}

// Constructor for instances of writer struct
func newWriter() *writer {
	self := &writer{
		languages_info:  make(map[string]map[string]any),
		custom_mappings: make(map[string]map[string]any),
		languages_used:  make(map[string]struct{}),
	}
	self.load_files()
	return self
}

// Create sorted list of string map keys
func sortKeys[k any](source_map map[string]k) []string {
	var sorted_keys []string
	for key := range source_map {
		sorted_keys = append(sorted_keys, key)
	}
	sort.Strings(sorted_keys)
	return sorted_keys
}
