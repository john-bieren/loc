package main

// For correct functionality, only run this file by using "go generate" in the main directory.

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
)

// languagesUrl is the link to the raw languages.json file in scc's github repository.
const languagesUrl = "https://raw.githubusercontent.com/boyter/scc/refs/heads/master/languages.json"

// languagesInfo is the map version of languages.json.
var languagesInfo map[string]map[string]any

// customMappings is the map version of the user's custom_mappings.json.
var customMappings map[string]map[string]any

// main generates languages.go from scc's languages.json and user's custom_mappings.json.
func main() {
	loadFiles()
	fileLines := generateText()

	fileText := strings.Join(fileLines, "")
	err := os.WriteFile("languages.go", []byte(fileText), 0666)
	if err != nil {
		panic(fmt.Sprintln("Error writing to languages.go:", err))
	}
}

// loadFiles loads languages.json from scc and custom_mappings.json from user into global variables.
func loadFiles() {
	// load languages.json
	resp, err := http.Get(languagesUrl)
	if err != nil {
		panic(fmt.Sprintln("Error getting languages.json:", err))
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(fmt.Sprintln("Error reading languages.json:", err))
	}

	err = json.Unmarshal(body, &languagesInfo)
	if err != nil {
		panic(fmt.Sprintln("Error unmarshalling languages.json:", err))
	}

	// load custom_mappings.json
	file, err := os.Open("custom_mappings.json")
	if err != nil {
		if !os.IsNotExist(err) {
			fmt.Println("Error opening custom_mappings.json", err)
		}
		return
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	err = decoder.Decode(&customMappings)
	if err != nil {
		fmt.Println("Error reading custom_mappings.json", err)
		return
	}
}

// generateText turns languagesInfo and customMappings into the lines of languages.go.
func generateText() []string {
	var extra string
	if len(customMappings) > 0 {
		extra = " with custom mappings"
	}
	doNotEditText := fmt.Sprintf("\n// This file was generated by generator.go%s, DO NOT EDIT IT.\n", extra)
	// fileLines contains the lines of languages.go.
	fileLines := []string{"package main\n", doNotEditText}

	// langsUsed contains the languages which appear as values in the extensions and fileNames maps.
	langsUsed := make(map[string]struct{})
	extensionMappings, fileNameMappings, singleCharMappings := gatherLanguageInfo()
	fileLines, langsUsed = generateExtensionsMap(fileLines, langsUsed, extensionMappings)
	fileLines, langsUsed = generateFileNamesMap(fileLines, langsUsed, fileNameMappings)
	fileLines = generateSingleCharsMap(fileLines, langsUsed, singleCharMappings)
	return fileLines
}

// gatherLanguageInfo loads relevant information from languages.json into maps.
func gatherLanguageInfo() (map[string]string, map[string]string, map[string][]any) {
	extensionMappings := make(map[string]string)
	fileNameMappings := make(map[string]string)
	singleCharMappings := make(map[string][]any)

	for language, info := range languagesInfo {
		// process extensions, resolve conflicts
		extensions, ok := info["extensions"].([]any)
		if !ok {
			fmt.Println("Error getting extensions for", language)
		} else {
			for _, ext := range extensions {
				ext, ok := ext.(string)
				if !ok {
					fmt.Println("Error reading extensions for", language)
				} else {
					currentMapping, ok := extensionMappings[ext]
					if ok {
						// sort languages alphabetically for deterministic output
						langs := strings.Split(currentMapping, " or ")
						langs = append(langs, language)
						sort.Strings(langs)
						extensionMappings[ext] = strings.Join(langs, " or ")
					} else {
						extensionMappings[ext] = language
					}
				}
			}
		}

		// process file names
		fileNames, ok := info["filenames"].([]any)
		// no warning because file names are optional in languages.json
		if ok {
			for _, file := range fileNames {
				file, ok := file.(string)
				if !ok {
					fmt.Println("Error reading file names for", language)
				} else {
					fileNameMappings[file] = language
				}
			}
		}

		// process single line comment characters
		chars, ok := info["line_comment"].([]any)
		if !ok {
			fmt.Println("Error getting single comment chars for", language)
		} else {
			singleCharMappings[language] = chars
		}
	}

	return extensionMappings, fileNameMappings, singleCharMappings
}

// generateExtensionsMap generates the definition for the extensions map.
func generateExtensionsMap(
	fileLines []string,
	langsUsed map[string]struct{},
	extensionMappings map[string]string,
) ([]string, map[string]struct{}) {
	// create union of extensionMappings and customMappings, record languages referenced
	customExtensions, ok := customMappings["extensions"]
	if ok {
		for extension, language := range customExtensions {
			language, ok := language.(string)
			if !ok {
				fmt.Println("Error reading custom extensions for", language)
			} else {
				extensionMappings[extension] = language
			}
		}
	}

	// record file lines
	fileLines = append(fileLines, "\n// extensions is the map of languages and extensions recognized as code.")
	fileLines = append(fileLines, "\nvar extensions = map[string]string{")
	for _, extension := range sortKeys(extensionMappings) {
		language := extensionMappings[extension]
		// skip custom mappings to blank strings
		if language != "" {
			newLine := fmt.Sprintf("\n\t\"%s\": \"%s\",", extension, language)
			fileLines = append(fileLines, newLine)
			langsUsed[language] = struct{}{}
		}
	}
	fileLines = append(fileLines, "\n}\n")
	return fileLines, langsUsed
}

// generateFileNamesMap generates the definition for the fileNames map.
func generateFileNamesMap(
	fileLines []string,
	langsUsed map[string]struct{},
	fileNameMappings map[string]string,
) ([]string, map[string]struct{}) {
	// create union of fileNameMappings and customMappings, record languages referenced
	customFileNames, ok := customMappings["fileNames"]
	if ok {
		for fileName, language := range customFileNames {
			language, ok := language.(string)
			if !ok {
				fmt.Println("Error reading custom file names for", language)
			} else {
				fileNameMappings[fileName] = language
			}
		}
	}

	// record file lines
	fileLines = append(fileLines, "\n// fileNames is the map of specific file names recognized as a particular language.")
	fileLines = append(fileLines, "\nvar fileNames = map[string]string{")
	for _, fileName := range sortKeys(fileNameMappings) {
		language := fileNameMappings[fileName]
		// skip custom mappings to blank strings
		if language != "" {
			newLine := fmt.Sprintf("\n\t\"%s\": \"%s\",", fileName, language)
			fileLines = append(fileLines, newLine)
			langsUsed[language] = struct{}{}
		}
	}
	fileLines = append(fileLines, "\n}\n")
	return fileLines, langsUsed
}

// generateSingleCharsMap generates the definition for the singleLineCommentChars map.
func generateSingleCharsMap(
	fileLines []string,
	langsUsed map[string]struct{},
	singleCharMappings map[string][]any,
) []string {
	// create union of singleCharMappings and customSingleChars
	customSingleChars, ok := customMappings["singleLineCommentChars"]
	if ok {
		for language, chars := range customSingleChars {
			chars, ok := chars.([]any)
			if !ok {
				fmt.Println("Error getting custom single comment chars for", language)
			} else {
				singleCharMappings[language] = chars
			}
		}
	}

	// record file lines
	fileLines = append(fileLines, "\n// singleLineCommentChars is the map of single-line comment characters for all languages.")
	fileLines = append(fileLines, "\nvar singleLineCommentChars = map[string][]string{")
	// add escape characters where necessary
	addEscapeChars := map[string]string{"\"": "\\\""}
	for _, language := range sortKeys(singleCharMappings) {
		// skip languages that don't appear in either of the other maps
		if _, ok := langsUsed[language]; !ok {
			continue
		}

		charSet := singleCharMappings[language]
		if len(charSet) > 0 {
			var chars []string
			for _, char := range charSet {
				char, ok := char.(string)
				if !ok {
					fmt.Println("Error reading single comment chars for", language)
				}
				if escapedChar, ok := addEscapeChars[char]; ok {
					chars = append(chars, escapedChar)
				} else {
					chars = append(chars, char)
				}
			}
			newLine := fmt.Sprintf("\n\t\"%s\": {\"%s\"},", language, strings.Join(chars, "\", \""))
			fileLines = append(fileLines, newLine)
		} else {
			fileLines = append(fileLines, fmt.Sprintf("\n\t\"%s\": {},", language))
		}
	}
	fileLines = append(fileLines, "\n}\n")
	return fileLines
}

// sortKeys creates a sorted slice of a map's string keys.
func sortKeys[k any](sourceMap map[string]k) []string {
	var sortedKeys []string
	for key := range sourceMap {
		sortedKeys = append(sortedKeys, key)
	}
	sort.Strings(sortedKeys)
	return sortedKeys
}
