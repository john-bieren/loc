package main

// For correct functionality, only run this file by using "go generate" in the main directory.

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
)

// languages_url is the link to the raw languages.json file in scc's github repository.
var languages_url = "https://raw.githubusercontent.com/boyter/scc/refs/heads/master/languages.json"

type writer struct {
	languages_info  map[string]map[string]any
	custom_mappings map[string]map[string]any
	file_lines      []string
	languages_used  map[string]struct{}
}

// loadFiles loads languages.json from scc and custom_mappings.json from user.
func (w *writer) loadFiles() {
	// load languages.json
	resp, err := http.Get(languages_url)
	if err != nil {
		panic(fmt.Sprintln("Error accessing languages.json:", err))
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(fmt.Sprintln("Error reading languages.json:", err))
	}

	err = json.Unmarshal(body, &w.languages_info)
	if err != nil {
		panic(fmt.Sprintln("Error unmarshalling languages.json:", err))
	}

	// load custom_mappings.json
	file, err := os.Open("custom_mappings.json")
	if err != nil {
		if !os.IsNotExist(err) {
			fmt.Println("Error opening custom_mappings.json", err)
		}
		return
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	err = decoder.Decode(&w.custom_mappings)
	if err != nil {
		fmt.Println("Error reading custom_mappings.json", err)
		return
	}
}

// writeFile generates the file lines and writes them to languages.go.
func (w *writer) writeFile() {
	w.generateText()

	file_text := strings.Join(w.file_lines, "")
	err := os.WriteFile("languages.go", []byte(file_text), 0666)
	if err != nil {
		panic(fmt.Sprintln("Error writing to languages.go:", err))
	}
}

// generateText turns languages_info and custom_mappings into the lines of languages.go.
func (w *writer) generateText() {
	var extra string
	if len(w.custom_mappings) > 0 {
		extra = " with custom mappings"
	}
	do_not_edit_text := fmt.Sprintf("\n// This file was generated by generator.go%s, DO NOT EDIT IT.\n", extra)
	w.file_lines = append(w.file_lines, "package main\n", do_not_edit_text)

	extension_mappings, filename_mappings, single_char_mappings := w.gatherLanguageInfo()
	w.generateExtensionsMap(extension_mappings)
	w.generateFilenamesMap(filename_mappings)
	w.generateSingleCharsMap(single_char_mappings)
}

// gatherLanguageInfo loads relevant information from languages.json into maps.
func (w *writer) gatherLanguageInfo() (map[string]string, map[string]string, map[string][]any) {
	extension_mappings := make(map[string]string)
	filename_mappings := make(map[string]string)
	single_char_mappings := make(map[string][]any)

	for language, info := range w.languages_info {
		// process extensions, resolve conflicts
		extensions, ok := info["extensions"].([]any)
		if !ok {
			fmt.Println("Error getting extensions for", language)
		} else {
			for _, ext := range extensions {
				ext, ok := ext.(string)
				if !ok {
					fmt.Println("Error reading extensions for", language)
				} else {
					current_mapping, ok := extension_mappings[ext]
					if ok {
						// sort languages alphabetically for deterministic output
						langs := strings.Split(current_mapping, " or ")
						langs = append(langs, language)
						sort.Strings(langs)
						extension_mappings[ext] = strings.Join(langs, " or ")
					} else {
						extension_mappings[ext] = language
					}
				}
			}
		}

		// process filenames
		filenames, ok := info["filenames"].([]any)
		// no warning because filenames are optional in languages.json
		if ok {
			for _, file := range filenames {
				file, ok := file.(string)
				if !ok {
					fmt.Println("Error reading filenames for", language)
				} else {
					filename_mappings[file] = language
				}
			}
		}

		// process single line comment characters
		chars, ok := info["line_comment"].([]any)
		if !ok {
			fmt.Println("Error getting single comment chars for", language)
		} else {
			single_char_mappings[language] = chars
		}
	}

	return extension_mappings, filename_mappings, single_char_mappings
}

// generateExtensionsMap generates the definition for the extensions map.
func (w *writer) generateExtensionsMap(extension_mappings map[string]string) {
	// create union of extension_mappings and custom_mappings, record languages referenced
	custom_extensions, ok := w.custom_mappings["extensions"]
	if ok {
		for extension, language := range custom_extensions {
			language, ok := language.(string)
			if !ok {
				fmt.Println("Error reading custom extensions for", language)
			} else {
				extension_mappings[extension] = language
			}
		}
	}

	// record file lines
	w.file_lines = append(w.file_lines, "\n// extensions is the map of languages and extensions recognized as code.")
	w.file_lines = append(w.file_lines, "\nvar extensions = map[string]string{")
	for _, extension := range sortKeys(extension_mappings) {
		language := extension_mappings[extension]
		// skip custom mappings to blank strings
		if language != "" {
			new_line := fmt.Sprintf("\n\t\".%s\": \"%s\",", extension, language)
			w.file_lines = append(w.file_lines, new_line)
			w.languages_used[language] = struct{}{}
		}
	}
	w.file_lines = append(w.file_lines, "\n}\n")
}

// generateFilenamesMap generates the definition for the filenames map.
func (w *writer) generateFilenamesMap(filename_mappings map[string]string) {
	// create union of filename_mappings and custom_mappings, record languages referenced
	custom_filenames, ok := w.custom_mappings["filenames"]
	if ok {
		for filename, language := range custom_filenames {
			language, ok := language.(string)
			if !ok {
				fmt.Println("Error reading custom filenames for", language)
			} else {
				filename_mappings[filename] = language
			}
		}
	}

	// record file lines
	w.file_lines = append(w.file_lines, "\n// filenames is the map of specific file names recognized as a particular language.")
	w.file_lines = append(w.file_lines, "\nvar filenames = map[string]string{")
	for _, filename := range sortKeys(filename_mappings) {
		language := filename_mappings[filename]
		// skip custom mappings to blank strings
		if language != "" {
			new_line := fmt.Sprintf("\n\t\"%s\": \"%s\",", filename, language)
			w.file_lines = append(w.file_lines, new_line)
			w.languages_used[language] = struct{}{}
		}
	}
	w.file_lines = append(w.file_lines, "\n}\n")
}

// generateSingleCharsMap generates the definition for the single_line_comment_chars map.
func (w *writer) generateSingleCharsMap(single_char_mappings map[string][]any) {
	// create union of single_char_mappings and custom_single_chars
	custom_single_chars, ok := w.custom_mappings["single_line_comment_chars"]
	if ok {
		for language, chars := range custom_single_chars {
			chars, ok := chars.([]any)
			if !ok {
				fmt.Println("Error getting custom single comment chars for", language)
			} else {
				single_char_mappings[language] = chars
			}
		}
	}

	// record file lines
	w.file_lines = append(w.file_lines, "\n// single_line_comment_chars is the map of single-line comment characters for all languages.")
	w.file_lines = append(w.file_lines, "\nvar single_line_comment_chars = map[string][]string{")
	// add escape characters where necessary
	add_escape_chars := map[string]string{"\"": "\\\""}
	for _, language := range sortKeys(single_char_mappings) {
		// skip languages that don't appear in either of the other maps
		if _, ok := w.languages_used[language]; !ok {
			continue
		}

		char_set := single_char_mappings[language]
		if len(char_set) > 0 {
			var chars []string
			for _, char := range char_set {
				char, ok := char.(string)
				if !ok {
					fmt.Println("Error reading single comment chars for", language)
				}
				if escaped_char, ok := add_escape_chars[char]; ok {
					chars = append(chars, escaped_char)
				} else {
					chars = append(chars, char)
				}
			}
			new_line := fmt.Sprintf("\n\t\"%s\": {\"%s\"},", language, strings.Join(chars, "\", \""))
			w.file_lines = append(w.file_lines, new_line)
		} else {
			w.file_lines = append(w.file_lines, fmt.Sprintf("\n\t\"%s\": {},", language))
		}
	}
	w.file_lines = append(w.file_lines, "\n}\n")
}

// main generates languages.go from scc's languages.json and user's custom_mappings.json.
func main() {
	writer := newWriter()
	writer.writeFile()
}

// newWriter is the constructor for instances of the writer struct.
func newWriter() *writer {
	self := &writer{
		languages_info:  make(map[string]map[string]any),
		custom_mappings: make(map[string]map[string]any),
		languages_used:  make(map[string]struct{}),
	}
	self.loadFiles()
	return self
}

// sortKeys creates a sorted slice of a map's string keys.
func sortKeys[k any](source_map map[string]k) []string {
	var sorted_keys []string
	for key := range source_map {
		sorted_keys = append(sorted_keys, key)
	}
	sort.Strings(sorted_keys)
	return sorted_keys
}
