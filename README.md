# loc

A command line utility for recursively counting lines of code in directories and their subdirectories by language.

### Example output

<pre>
<code>>>> loc -d
<b>Language: loc | size | files</b>
5 langs: 6,419 | 346.0 kb | 41
Python: 5,684 | 318.2 kb | 34
C++: 351 | 14.3 kb | 2
C: 323 | 11.4 kb | 2
Ruby: 33 | 1.1 kb | 1
Powershell: 28 | 952 b | 2
    dir1\
     Python: 4,100 | 233.1 kb | 14
    dir2\
     5 langs: 1,929 | 91.3 kb | 25
     Python: 1,194 | 63.5 kb | 18
     C++: 351 | 14.3 kb | 2
     C: 323 | 11.4 kb | 2
     Ruby: 33 | 1.1 kb | 1
     Powershell: 28 | 952 b | 2
</code></pre>

## Usage

This usage information can be found by running `loc --help`:

```
Usage: loc [options] [dirs]
         Options must come before dirs
         Option flags cannot be combined (e.g. use -d -f instead of -df)
         Option flags and arguments are case sensitive
         Dirs are the names/paths of directories to search (cwd by default)

Options:
        -d         Print loc by directory
            -pd <int>  Maximum depth of subdirectories to print (default: 1,000)
        --dot      Include dot directories (excluded by default)
        -ed <str>  Directory trees to exclude (name or path, e.g. "node_modules,src/constants")
        -ee <str>  Extensions to exclude (e.g. "json,md,css")
        -ef <str>  Files to exclude (name or path, e.g. "htmx.js,src/version.c")
        -el <str>  Languages to exclude (e.g. "HTML,Plain Text,YAML")
        -f         Print loc by file
            -mf <int>  Maximum number of files to print per directory (default: 100,000)
        -fr <int>  Number of file-reading goroutines (default: system-specific)
        -id <str>  Directory trees to include, excluding others (name or path, e.g. "build,src/lib")
        -ie <str>  Extensions to include, excluding others (e.g. "go,sh,zig")
        -if <str>  Files to include, excluding others (name or path, e.g. "main.lua,src/index.ts")
        -il <str>  Languages to include, excluding others (e.g. "Python,JavaScript,C++")
        -ml <int>  Maximum number of languages to print per directory (default: 1,000)
        -p         Print loc as a percentage of overall total
        -q         Suppress non-critical error messages
        -s  <str>  How to sort results ["loc", "size", "files"] (default: "loc")
        -sd <int>  Maximum depth of subdirectories to search (default: 1,000)
        --help     Print this message and exit
        --license  Print license information and exit
        --version  Print version and exit
```

## Install

### Binary releases

Binaries for Windows and Linux on x86_64 are [available](https://github.com/john-bieren/loc/releases).

### Build from source

1. Clone the repository:
    ```
    git clone https://github.com/john-bieren/loc.git
    ```
2. Navigate to the project directory and generate `languages.go`, the program's store of language information like file extensions and comment characters:
    ```
    go generate
    ```
    See the [custom mappings](https://github.com/john-bieren/loc?tab=readme-ov-file#custom-mappings-must-build-from-source) section for more information about `languages.go`.
3. Compile the program:
    ```
    go build
    ```

## Performance note

On Windows, loc may be slowed down significantly by Windows Defender's real-time protection. You can fix this by adding the `loc.exe` process to the exclusions list, **but only do this if you build from source and understand the codebase**, as blindly trusting executable files is very dangerous.

## Limitations

I'm new to Go, and this is just a personal project. As such, loc has some notable limitations:
* Multi-line comments and non-comment docstrings are counted as lines of code.
* Traversal of directory trees is not concurrent, though file processing is.
* Files are assigned a language based only on their extension, resulting in a few conflicts where extensions belong to multiple languages. These conflicts are resolved by mapping the extensions to "lang 1 or lang 2", unless applicable custom mappings are used.

There are similar, more advanced programs, like [scc](https://github.com/boyter/scc), with more features and better methods for counting lines of code.

## Custom mappings (must build from source)

loc uses three maps, located in `languages.go`, to store language information:
* `extensions`, which maps extensions to languages
* `fileNames`, which maps specific file names to languages
* `singleLineCommentChars`, which maps languages to a list of their single-line comment characters

`languages.go` is based on scc's [languages.json](https://github.com/boyter/scc/blob/master/languages.json), and is generated by `generator.go`. You can create or re-generate `languages.go` with the most recent changes from scc by running `go generate` in the project directory and then running `go build` to compile the program with the new mappings. If you want to overwrite key-value pairs in these maps, or add new ones, `generator.go` can process custom mappings. In the project directory, create a file named `custom_mappings.json`, list your mappings as demonstrated below, then run `go generate` and `go build`.
```JSON
{
    "extensions": {
        "heex": "HEEx",
        "json": "JSON",
        "st": "Smalltalk",
        "yaml": "YAML",
        "yml": "YAML"
    },
    "fileNames": {
        "LICENCE": "License",
        "LICENSE": "License",
        "LICENCE.txt": "License",
        "LICENSE.txt": "License",
        "README": "README",
        "README.md": "README",
        "exclude": "Git Exclude"
    },
    "singleLineCommentChars": {
        "Git Exclude": ["#"]
    }
}
```
Shown here are the custom mappings used in the most recent binary release.
